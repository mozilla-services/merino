<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An extensible Statsd client for Rust!"><meta name="keywords" content="rust, rustlang, rust-lang, cadence"><title>cadence - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../cadence/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../cadence/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate cadence</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.26.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="cadence" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../cadence/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">cadence</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/cadence/lib.rs.html#11-450">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An extensible Statsd client for Rust!</p>
<p>Cadence is a fast and flexible way to emit Statsd metrics from your application.</p>
<h3 id="features"><a href="#features">Features</a></h3>
<ul>
<li><a href="https://docs.rs/cadence/">Support</a> for emitting counters, timers, histograms, distributions,
gauges, meters, and sets to Statsd over UDP (or optionally Unix sockets).</li>
<li>Support for alternate backends via the <code>MetricSink</code> trait.</li>
<li>Support for <a href="https://docs.datadoghq.com/developers/dogstatsd/">Datadog</a> style metrics tags.</li>
<li><a href="https://docs.rs/cadence-macros/">Macros</a> to simplify common calls to emit metrics</li>
<li>A simple yet flexible API for sending metrics.</li>
</ul>
<h3 id="install"><a href="#install">Install</a></h3>
<p>To make use of <code>cadence</code> in your project, add it as a dependency in your <code>Cargo.toml</code> file.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
cadence = &quot;x.y.z&quot;</code></pre></div>
<p>That’s all you need!</p>
<h3 id="usage"><a href="#usage">Usage</a></h3>
<p>Some examples of how to use Cadence are shown below. The examples start
simple and work up to how you should be using Cadence in a production
application.</p>
<h4 id="simple-use"><a href="#simple-use">Simple Use</a></h4>
<p>Simple usage of Cadence is shown below. In this example, we just import
the client, create an instance that will write to some imaginary metrics
server, and send a few metrics.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="comment">// Create client that will write to the given host over UDP.</span>
<span class="comment">//</span>
<span class="comment">// Note that you&#39;ll probably want to actually handle any errors creating</span>
<span class="comment">// the client when you use it for real in your application. We&#39;re just</span>
<span class="comment">// using .unwrap() here since this is an example!</span>
<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">UdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.metrics&quot;</span>, <span class="ident">sink</span>);

<span class="comment">// Emit metrics!</span>
<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;some.counter&quot;</span>, <span class="number">1</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;some.methodCall&quot;</span>, <span class="number">42</span>);
<span class="ident">client</span>.<span class="ident">gauge</span>(<span class="string">&quot;some.thing&quot;</span>, <span class="number">7</span>);
<span class="ident">client</span>.<span class="ident">meter</span>(<span class="string">&quot;some.value&quot;</span>, <span class="number">5</span>);</code></pre></div>
<h4 id="buffered-udp-sink"><a href="#buffered-udp-sink">Buffered UDP Sink</a></h4>
<p>While sending a metric over UDP is very fast, the overhead of frequent
network calls can start to add up. This is especially true if you are
writing a high performance application that emits a lot of metrics.</p>
<p>To make sure that metrics aren’t interfering with the performance of
your application, you may want to use a <code>MetricSink</code> implementation that
buffers multiple metrics before sending them in a single network
operation. For this, there’s <code>BufferedUdpMetricSink</code>. An example of
using this sink is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">BufferedUdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">BufferedUdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);</code></pre></div>
<p>As you can see, using this buffered UDP sink is no more complicated
than using the regular, non-buffered, UDP sink.</p>
<p>The only downside to this sink is that metrics aren’t written to the
Statsd server until the buffer is full. If you have a busy application
that is constantly emitting metrics, this shouldn’t be a problem.
However, if your application only occasionally emits metrics, this sink
might result in the metrics being delayed for a little while until the
buffer fills. In this case, it may make sense to use the <code>UdpMetricSink</code>
since it does not do any buffering.</p>
<h4 id="queuing-asynchronous-metric-sink"><a href="#queuing-asynchronous-metric-sink">Queuing Asynchronous Metric Sink</a></h4>
<p>To make sure emitting metrics doesn’t interfere with the performance
of your application (even though emitting metrics is generally quite
fast), it’s probably a good idea to make sure metrics are emitted in
in a different thread than your application thread.</p>
<p>To allow you to do this, there is <code>QueuingMetricSink</code>. This sink allows
you to wrap any other metric sink and send metrics to it via a queue,
as it emits metrics in another thread, asynchronously from the flow of
your application.</p>
<p>The requirements for the wrapped metric sink are that it is thread
safe, meaning that it implements the <code>Send</code> and <code>Sync</code> traits. If
you’re using the <code>QueuingMetricSink</code> with another sink from Cadence,
you don’t need to worry: they are all thread safe.</p>
<p>An example of using the <code>QueuingMetricSink</code> to wrap a buffered UDP
metric sink is given below. This is the preferred way to use Cadence
in production.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">QueuingMetricSink</span>, <span class="ident">BufferedUdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">udp_sink</span> <span class="op">=</span> <span class="ident">BufferedUdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">queuing_sink</span> <span class="op">=</span> <span class="ident">QueuingMetricSink::from</span>(<span class="ident">udp_sink</span>);
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">queuing_sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);</code></pre></div>
<p>In the example above, we use the default constructor for the queuing
sink which creates an <strong>unbounded</strong> queue, with no maximum size, to connect
the main thread where the client sends metrics to the background thread
in which the wrapped sink is running. If instead, you want to create a
<strong>bounded</strong> queue with a maximum size, you can use the <code>with_capacity</code>
constructor. An example of this is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">QueuingMetricSink</span>, <span class="ident">BufferedUdpMetricSink</span>,
              <span class="ident">DEFAULT_PORT</span>};

<span class="comment">// Queue with a maximum capacity of 128K elements</span>
<span class="kw">const</span> <span class="ident">QUEUE_SIZE</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">128</span> <span class="op">*</span> <span class="number">1024</span>;

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">udp_sink</span> <span class="op">=</span> <span class="ident">BufferedUdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">queuing_sink</span> <span class="op">=</span> <span class="ident">QueuingMetricSink::with_capacity</span>(<span class="ident">udp_sink</span>, <span class="ident">QUEUE_SIZE</span>);
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">queuing_sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);</code></pre></div>
<p>Using a <code>QueuingMetricSink</code> with a capacity set means that when the queue
is full, attempts to emit metrics via the <code>StatsdClient</code> will fail. While
this is bad, the alternative (if you instead used an unbounded queue) is
for unsent metrics to slowly use up more and more memory until your
application exhausts all memory.</p>
<p>Using an <strong>unbounded</strong> queue means that the sending of metrics can absorb
slowdowns of sending metrics until your application runs out of memory.
Using a <strong>bounded</strong> queue puts a cap on the amount of memory that sending
metrics will use in your application. This is a tradeoff that users of
Cadence must decide for themselves.</p>
<h4 id="use-with-tags"><a href="#use-with-tags">Use With Tags</a></h4>
<p>Adding tags to metrics is accomplished via the use of each of the <code>_with_tags</code>
methods that are part of the Cadence <code>StatsdClient</code> struct. An example of using
these methods is given below. Note that tags are an extension to the Statsd
protocol and so may not be supported by all servers.</p>
<p>See the <a href="https://docs.datadoghq.com/developers/dogstatsd/">Datadog docs</a> for
more information.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">Metric</span>, <span class="ident">StatsdClient</span>, <span class="ident">NopMetricSink</span>};

<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">NopMetricSink</span>);

<span class="kw">let</span> <span class="ident">res</span> <span class="op">=</span> <span class="ident">client</span>.<span class="ident">count_with_tags</span>(<span class="string">&quot;my.counter&quot;</span>, <span class="number">29</span>)
    .<span class="ident">with_tag</span>(<span class="string">&quot;host&quot;</span>, <span class="string">&quot;web03.example.com&quot;</span>)
    .<span class="ident">with_tag_value</span>(<span class="string">&quot;beta-test&quot;</span>)
    .<span class="ident">try_send</span>();

<span class="macro">assert_eq!</span>(
    <span class="macro">concat!</span>(
        <span class="string">&quot;my.prefix.my.counter:29|c|#&quot;</span>,
        <span class="string">&quot;host:web03.example.com,&quot;</span>,
        <span class="string">&quot;beta-test&quot;</span>
    ),
    <span class="ident">res</span>.<span class="ident">unwrap</span>().<span class="ident">as_metric_str</span>()
);</code></pre></div>
<h4 id="implemented-traits"><a href="#implemented-traits">Implemented Traits</a></h4>
<p>Each of the methods that the Cadence <code>StatsdClient</code> struct uses to send
metrics are implemented as a trait. There is also a trait that combines
all of these other traits. If we want, we can just use one of the trait
types to refer to the client instance. This might be useful to you if
you’d like to swap out the actual Cadence client with a dummy version
when you are unit testing your code or want to abstract away all the
implementation details of the client being used behind a trait and
pointer.</p>
<p>Each of these traits are exported in the prelude module. They are also
available in the main module but aren’t typically used like that.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">User</span> {
    <span class="ident">id</span>: <span class="ident">u64</span>,
    <span class="ident">username</span>: <span class="ident">String</span>,
    <span class="ident">email</span>: <span class="ident">String</span>
}


<span class="comment">// Here&#39;s a simple DAO (Data Access Object) that doesn&#39;t do anything but</span>
<span class="comment">// uses a metric client to keep track of the number of times the</span>
<span class="comment">// &#39;getUserById&#39; method gets called.</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyUserDao</span> {
    <span class="ident">metrics</span>: <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">MetricClient</span><span class="op">&gt;</span>
}


<span class="kw">impl</span> <span class="ident">MyUserDao</span> {
    <span class="comment">// Create a new instance that will use the StatsdClient</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetricClient</span> <span class="op">+</span> <span class="lifetime">&#39;static</span><span class="op">&gt;</span>(<span class="ident">metrics</span>: <span class="ident">T</span>) -&gt; <span class="ident">MyUserDao</span> {
        <span class="ident">MyUserDao</span> { <span class="ident">metrics</span>: <span class="ident">Box::new</span>(<span class="ident">metrics</span>) }
    }

    <span class="doccomment">/// Get a new user by their ID</span>
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_user_by_id</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">u64</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">User</span><span class="op">&gt;</span> {
        <span class="self">self</span>.<span class="ident">metrics</span>.<span class="ident">count</span>(<span class="string">&quot;getUserById&quot;</span>, <span class="number">1</span>);
        <span class="prelude-val">None</span>
    }
}


<span class="comment">// Create a new Statsd client that writes to &quot;metrics.example.com&quot;</span>
<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">UdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">metrics</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;counter.example&quot;</span>, <span class="ident">sink</span>);

<span class="comment">// Create a new instance of the DAO that will use the client</span>
<span class="kw">let</span> <span class="ident">dao</span> <span class="op">=</span> <span class="ident">MyUserDao::new</span>(<span class="ident">metrics</span>);

<span class="comment">// Try to lookup a user by ID!</span>
<span class="kw">match</span> <span class="ident">dao</span>.<span class="ident">get_user_by_id</span>(<span class="number">123</span>) {
    <span class="prelude-val">Some</span>(<span class="ident">u</span>) =&gt; <span class="macro">println!</span>(<span class="string">&quot;Found a user!&quot;</span>),
    <span class="prelude-val">None</span> =&gt; <span class="macro">println!</span>(<span class="string">&quot;No user!&quot;</span>)
};</code></pre></div>
<h4 id="quiet-metric-sending-and-error-handling"><a href="#quiet-metric-sending-and-error-handling">Quiet Metric Sending and Error Handling</a></h4>
<p>When sending metrics sometimes you don’t really care about the <code>Result</code> of
trying to send it or maybe you just don’t want to deal with it inline with
the rest of your code. In order to handle this, Cadence allows you to set a
default error handler. This handler is invoked when there are errors sending
metrics so that the calling code doesn’t have to deal with them.</p>
<p>An example of configuring an error handler and an example of when it might
be invoked is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">MetricError</span>, <span class="ident">StatsdClient</span>, <span class="ident">NopMetricSink</span>};

<span class="kw">fn</span> <span class="ident">my_error_handler</span>(<span class="ident">err</span>: <span class="ident">MetricError</span>) {
    <span class="macro">println!</span>(<span class="string">&quot;Metric error! {}&quot;</span>, <span class="ident">err</span>);
}

<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::builder</span>(<span class="string">&quot;prefix&quot;</span>, <span class="ident">NopMetricSink</span>)
    .<span class="ident">with_error_handler</span>(<span class="ident">my_error_handler</span>)
    .<span class="ident">build</span>();

<span class="comment">// When sending metrics via the `MetricBuilder` used for assembling tags,</span>
<span class="comment">// callers may opt into sending metrics quietly via the `.send()` method</span>
<span class="comment">// as opposed to the `.try_send()` method</span>
<span class="ident">client</span>.<span class="ident">count_with_tags</span>(<span class="string">&quot;some.counter&quot;</span>, <span class="number">42</span>)
    .<span class="ident">with_tag</span>(<span class="string">&quot;region&quot;</span>, <span class="string">&quot;us-east-2&quot;</span>)
    .<span class="ident">send</span>();</code></pre></div>
<h4 id="custom-metric-sinks"><a href="#custom-metric-sinks">Custom Metric Sinks</a></h4>
<p>The Cadence <code>StatsdClient</code> uses implementations of the <code>MetricSink</code>
trait to send metrics to a metric server. Most users of the Cadence
library probably want to use the <code>QueuingMetricSink</code> wrapping an instance
of the <code>BufferedMetricSink</code>.</p>
<p>However, maybe you want to do something not covered by an existing sink.
An example of creating a custom sink is below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::io</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">MetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">MyMetricSink</span>;


<span class="kw">impl</span> <span class="ident">MetricSink</span> <span class="kw">for</span> <span class="ident">MyMetricSink</span> {
    <span class="kw">fn</span> <span class="ident">emit</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">metric</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) -&gt; <span class="ident">io::Result</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
        <span class="comment">// Your custom metric sink implementation goes here!</span>
        <span class="prelude-val">Ok</span>(<span class="number">0</span>)
    }
}


<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">MyMetricSink</span>;
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">42</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.method.time&quot;</span>, <span class="number">25</span>);
<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;some.other.counter&quot;</span>, <span class="number">1</span>);</code></pre></div>
<h4 id="custom-udp-socket"><a href="#custom-udp-socket">Custom UDP Socket</a></h4>
<p>Most users of the Cadence <code>StatsdClient</code> will be using it to send metrics
over a UDP socket. If you need to customize the socket, for example you
want to use the socket in blocking mode but set a write timeout, you can
do that as demonstrated below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::net::UdpSocket</span>;
<span class="kw">use</span> <span class="ident">std::time::Duration</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">UdpMetricSink</span>, <span class="ident">DEFAULT_PORT</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UdpSocket::bind</span>(<span class="string">&quot;0.0.0.0:0&quot;</span>).<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_write_timeout</span>(<span class="prelude-val">Some</span>(<span class="ident">Duration::from_millis</span>(<span class="number">1</span>))).<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">host</span> <span class="op">=</span> (<span class="string">&quot;metrics.example.com&quot;</span>, <span class="ident">DEFAULT_PORT</span>);
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">UdpMetricSink::from</span>(<span class="ident">host</span>, <span class="ident">socket</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);
<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;some.event&quot;</span>, <span class="number">33</span>);
<span class="ident">client</span>.<span class="ident">set</span>(<span class="string">&quot;users.uniques&quot;</span>, <span class="number">42</span>);</code></pre></div>
<h4 id="unix-sockets"><a href="#unix-sockets">Unix Sockets</a></h4>
<p>Cadence also supports using Unix datagram sockets with the <code>UnixMetricSink</code>  or
<code>BufferedUnixMetricSink</code>. Unix sockets can be used for sending metrics to a server
or agent running on the same machine (physical machine, VM, containers in a pod)
as your application. Unix sockets are somewhat similar to UDP sockets with a few
important differences:</p>
<ul>
<li>Sending metrics on a socket that doesn’t exist or is not being listened to will
result in an error.</li>
<li>Metrics sent on a connected socket are guaranteed to be delievered (i.e. they are
reliable as opposed to UDP sockets). However, it’s still possible that the metrics
won’t be read by the server due to a variety of environment and server specific
reasons.</li>
</ul>
<p>An example of using the sinks is given below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">std::os::unix::net::UnixDatagram</span>;
<span class="kw">use</span> <span class="ident">cadence::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">cadence</span>::{<span class="ident">StatsdClient</span>, <span class="ident">BufferedUnixMetricSink</span>};

<span class="kw">let</span> <span class="ident">socket</span> <span class="op">=</span> <span class="ident">UnixDatagram::unbound</span>().<span class="ident">unwrap</span>();
<span class="ident">socket</span>.<span class="ident">set_nonblocking</span>(<span class="bool-val">true</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">sink</span> <span class="op">=</span> <span class="ident">BufferedUnixMetricSink::from</span>(<span class="string">&quot;/run/statsd.sock&quot;</span>, <span class="ident">socket</span>);
<span class="kw">let</span> <span class="ident">client</span> <span class="op">=</span> <span class="ident">StatsdClient::from_sink</span>(<span class="string">&quot;my.prefix&quot;</span>, <span class="ident">sink</span>);

<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;my.counter.thing&quot;</span>, <span class="number">29</span>);
<span class="ident">client</span>.<span class="ident">time</span>(<span class="string">&quot;my.service.call&quot;</span>, <span class="number">214</span>);
<span class="ident">client</span>.<span class="ident">count</span>(<span class="string">&quot;some.event&quot;</span>, <span class="number">33</span>);
<span class="ident">client</span>.<span class="ident">set</span>(<span class="string">&quot;users.uniques&quot;</span>, <span class="number">42</span>);</code></pre></div>
<p>NOTE: This feature is only available on Unix platforms (Linux, BSD, MacOS).</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="ext/index.html" title="cadence::ext mod">ext</a></div><div class="item-right docblock-short"><p>Advanced extension points for the Cadence library</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="cadence::prelude mod">prelude</a></div><div class="item-right docblock-short"><p>Export commonly used parts of Cadence for easy glob imports</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BufferedSpyMetricSink.html" title="cadence::BufferedSpyMetricSink struct">BufferedSpyMetricSink</a></div><div class="item-right docblock-short"><p><code>MetricSink</code> implementation that buffers metrics and writes them to the
<code>Sender</code> half of a channel while callers are given ownership of the <code>Receiver</code>
half.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BufferedUdpMetricSink.html" title="cadence::BufferedUdpMetricSink struct">BufferedUdpMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that buffers metrics before
sending them to a UDP socket.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BufferedUnixMetricSink.html" title="cadence::BufferedUnixMetricSink struct">BufferedUnixMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that buffers metrics before
sending them to a Unix socket.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Counter.html" title="cadence::Counter struct">Counter</a></div><div class="item-right docblock-short"><p>Counters are simple values incremented or decremented by a client.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Distribution.html" title="cadence::Distribution struct">Distribution</a></div><div class="item-right docblock-short"><p>Distributions represent a global statistical distribution of a set of values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Gauge.html" title="cadence::Gauge struct">Gauge</a></div><div class="item-right docblock-short"><p>Gauges are an instantaneous value determined by the client.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Histogram.html" title="cadence::Histogram struct">Histogram</a></div><div class="item-right docblock-short"><p>Histograms are values whose distribution is calculated by the server.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Meter.html" title="cadence::Meter struct">Meter</a></div><div class="item-right docblock-short"><p>Meters measure the rate at which events occur as determined by the server.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MetricBuilder.html" title="cadence::MetricBuilder struct">MetricBuilder</a></div><div class="item-right docblock-short"><p>Builder for adding tags to in-progress metrics.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MetricError.html" title="cadence::MetricError struct">MetricError</a></div><div class="item-right docblock-short"><p>Error generated by this library potentially wrapping another
type of error (exposed via the <code>Error</code> trait).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NopMetricSink.html" title="cadence::NopMetricSink struct">NopMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that discards all metrics.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.QueuingMetricSink.html" title="cadence::QueuingMetricSink struct">QueuingMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that wraps another implementation
and uses it to emit metrics asynchronously, in another thread.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Set.html" title="cadence::Set struct">Set</a></div><div class="item-right docblock-short"><p>Sets count the number of unique elements in a group.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SpyMetricSink.html" title="cadence::SpyMetricSink struct">SpyMetricSink</a></div><div class="item-right docblock-short"><p><code>MetricSink</code> implementation that writes all metrics to the <code>Sender</code> half of
a channel while callers are given ownership of the <code>Receiver</code> half.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StatsdClient.html" title="cadence::StatsdClient struct">StatsdClient</a></div><div class="item-right docblock-short"><p>Client for Statsd that implements various traits to record metrics.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.StatsdClientBuilder.html" title="cadence::StatsdClientBuilder struct">StatsdClientBuilder</a></div><div class="item-right docblock-short"><p>Builder for creating and customizing <code>StatsdClient</code> instances.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Timer.html" title="cadence::Timer struct">Timer</a></div><div class="item-right docblock-short"><p>Timers are a positive number of milliseconds between a start and end point.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UdpMetricSink.html" title="cadence::UdpMetricSink struct">UdpMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that emits metrics over UDP.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UnixMetricSink.html" title="cadence::UnixMetricSink struct">UnixMetricSink</a></div><div class="item-right docblock-short"><p>Implementation of a <code>MetricSink</code> that emits metrics over a Unix socket.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ErrorKind.html" title="cadence::ErrorKind enum">ErrorKind</a></div><div class="item-right docblock-short"><p>Potential categories an error from this library falls into.</p>
</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.DEFAULT_PORT.html" title="cadence::DEFAULT_PORT constant">DEFAULT_PORT</a></div><div class="item-right docblock-short"></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Compat.html" title="cadence::Compat trait">Compat</a></div><div class="item-right docblock-short"><p>Backwards compatibility shim for removed and deprecated methods.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Counted.html" title="cadence::Counted trait">Counted</a></div><div class="item-right docblock-short"><p>Trait for incrementing and decrementing counters.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.CountedExt.html" title="cadence::CountedExt trait">CountedExt</a></div><div class="item-right docblock-short"><p>Trait for convenience methods for counters</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Distributed.html" title="cadence::Distributed trait">Distributed</a></div><div class="item-right docblock-short"><p>Trait for recording distribution values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Gauged.html" title="cadence::Gauged trait">Gauged</a></div><div class="item-right docblock-short"><p>Trait for recording gauge values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Histogrammed.html" title="cadence::Histogrammed trait">Histogrammed</a></div><div class="item-right docblock-short"><p>Trait for recording histogram values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Metered.html" title="cadence::Metered trait">Metered</a></div><div class="item-right docblock-short"><p>Trait for recording meter values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Metric.html" title="cadence::Metric trait">Metric</a></div><div class="item-right docblock-short"><p>Trait for metrics to expose Statsd metric string slice representation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.MetricClient.html" title="cadence::MetricClient trait">MetricClient</a></div><div class="item-right docblock-short"><p>Trait that encompasses all other traits for sending metrics.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.MetricSink.html" title="cadence::MetricSink trait">MetricSink</a></div><div class="item-right docblock-short"><p>Trait for various backends that send Statsd metrics somewhere.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Setted.html" title="cadence::Setted trait">Setted</a></div><div class="item-right docblock-short"><p>Trait for recording set values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Timed.html" title="cadence::Timed trait">Timed</a></div><div class="item-right docblock-short"><p>Trait for recording timings in milliseconds.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.MetricResult.html" title="cadence::MetricResult type">MetricResult</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="cadence" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>