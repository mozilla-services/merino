<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Serde support for querystring-style strings"><meta name="keywords" content="rust, rustlang, rust-lang, serde_qs"><title>serde_qs - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../serde_qs/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate serde_qs</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.8.4</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all serde_qs's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="serde_qs" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">serde_qs</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/serde_qs/lib.rs.html#1-194" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Serde support for querystring-style strings</p>
<p>Querystrings are not formally defined and loosely take the form of
<em>nested</em> urlencoded queries.</p>
<p>This library aims for compatability with the syntax of
<a href="https://github.com/ljharb/qs">qs</a> and also of the
<a href="http://www.rubydoc.info/github/rack/rack/Rack/Utils#parse_nested_query-class_method"><code>Rack::Utils::parse_nested_query</code></a>
implementation.</p>
<p>For users who do <em>not</em> require nested URL parameters, it is highly
recommended that the <code>serde_urlencoded</code> crate is used instead, which
will almost certainly perform better for deserializing simple inputs.</p>
<h3 id="supported-types" class="section-header"><a href="#supported-types">Supported Types</a></h3>
<p>At the <strong>top level</strong>, <code>serde_qs</code> only supports <code>struct</code>, <code>map</code>, and <code>enum</code>.
These are the only top-level structs which can be de/serialized since
Querystrings rely on having a (key, value) pair for each field, which
necessitates this kind of structure.</p>
<p>However, after the top level you should find all supported types can be
de/serialized.</p>
<p>Note that integer keys are reserved for array indices. That is, a string of
the form <code>a[0]=1&amp;a[1]=3</code> will deserialize to the ordered sequence <code>a = [1,3]</code>.</p>
<h3 id="usage" class="section-header"><a href="#usage">Usage</a></h3>
<p>See the examples folder for a more detailed introduction.</p>
<p>Serializing/Deserializing is designed to work with maps and structs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_qs</span> <span class="kw">as</span> <span class="ident">qs</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Deserialize</span>, <span class="ident">Serialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Address</span> {
    <span class="ident">city</span>: <span class="ident">String</span>,
    <span class="ident">postcode</span>: <span class="ident">String</span>,
}
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Deserialize</span>, <span class="ident">Serialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">QueryParams</span> {
    <span class="ident">id</span>: <span class="ident">u8</span>,
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">address</span>: <span class="ident">Address</span>,
    <span class="ident">phone</span>: <span class="ident">u32</span>,
    <span class="ident">user_ids</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>,
}

<span class="kw">let</span> <span class="ident">params</span> <span class="op">=</span> <span class="ident">QueryParams</span> {
    <span class="ident">id</span>: <span class="number">42</span>,
    <span class="ident">name</span>: <span class="string">&quot;Acme&quot;</span>.<span class="ident">to_string</span>(),
    <span class="ident">phone</span>: <span class="number">12345</span>,
    <span class="ident">address</span>: <span class="ident">Address</span> {
        <span class="ident">city</span>: <span class="string">&quot;Carrot City&quot;</span>.<span class="ident">to_string</span>(),
        <span class="ident">postcode</span>: <span class="string">&quot;12345&quot;</span>.<span class="ident">to_string</span>(),
    },
    <span class="ident">user_ids</span>: <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
};
<span class="kw">let</span> <span class="ident">rec_params</span>: <span class="ident">QueryParams</span> <span class="op">=</span> <span class="ident">qs::from_str</span>(<span class="string">&quot;\
    name=Acme&amp;id=42&amp;phone=12345&amp;address[postcode]=12345&amp;\
    address[city]=Carrot+City&amp;user_ids[0]=1&amp;user_ids[1]=2&amp;\
    user_ids[2]=3&amp;user_ids[3]=4&quot;</span>)
    .<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">rec_params</span>, <span class="ident">params</span>);
</code></pre></div>
<h3 id="strict-vs-non-strict-modes" class="section-header"><a href="#strict-vs-non-strict-modes">Strict vs Non-Strict modes</a></h3>
<p><code>serde_qs</code> supports two operating modes, which can be specified using
<a href="struct.Config.html"><code>Config</code></a>, and is all about how <code>serde_qs</code> handles square brackets.</p>
<p>Techncially, square brackets should be encoded in URLs as <code>%5B</code> and <code>%5D</code>.
However, they are often used in their raw format to specify querystrings
such as <code>a[b]=123</code>.</p>
<p>In strict mode, <code>serde_qs</code> will only tolerate unencoded square brackets
to denote nested keys. So <code>a[b]=123</code> will decode as <code>{&quot;a&quot;: {&quot;b&quot;: 123}}</code>.
This means that encoded square brackets can actually be part of the key.
<code>a[b%5Bc%5D]=123</code> becomes <code>{&quot;a&quot;: {&quot;b[c]&quot;: 123}}</code>.</p>
<p>However, since some implementations will automatically encode everything
in the URL, we also have a non-strict mode. This means that <code>serde_qs</code>
will assume that any encoded square brackets in the string were meant to
be taken as nested keys. From the example before, <code>a[b%5Bc%5D]=123</code> will
now become <code>{&quot;a&quot;: {&quot;b&quot;: {&quot;c&quot;: 123 }}}</code>.</p>
<p>Non-strict mode can be useful when, as said before, some middleware
automatically encodes the brackets. But care must be taken to avoid
using keys with square brackets in them, or unexpected things can
happen.</p>
<h3 id="flatten-workaround" class="section-header"><a href="#flatten-workaround">Flatten workaround</a></h3>
<p>A current <a href="https://github.com/serde-rs/serde/issues/1183">known limitation</a>
in <code>serde</code> is deserializing <code>#[serde(flatten)]</code> structs for formats which
are not self-describing. This includes query strings: <code>12</code> can be an integer
or a string, for example.</p>
<p>We suggest the following workaround:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde</span>;
<span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_derive</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">serde_qs</span> <span class="kw">as</span> <span class="ident">qs</span>;

<span class="kw">use</span> <span class="ident">serde::de::Error</span>;

<span class="kw">fn</span> <span class="ident">from_str</span><span class="op">&lt;</span><span class="lifetime">&#39;de</span>, <span class="ident">D</span>, <span class="ident">S</span><span class="op">&gt;</span>(<span class="ident">deserializer</span>: <span class="ident">D</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">S</span>, <span class="ident">D::Error</span><span class="op">&gt;</span>
    <span class="kw">where</span> <span class="ident">D</span>: <span class="ident">serde::Deserializer</span><span class="op">&lt;</span><span class="lifetime">&#39;de</span><span class="op">&gt;</span>,
          <span class="ident">S</span>: <span class="ident">std::str::FromStr</span>
{
    <span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span> <span class="kw">as</span> <span class="ident">serde::Deserialize</span><span class="op">&gt;</span><span class="ident">::deserialize</span>(<span class="ident">deserializer</span>)<span class="question-mark">?</span>;
    <span class="ident">S::from_str</span>(<span class="kw-2">&amp;</span><span class="ident">s</span>).<span class="ident">map_err</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> <span class="ident">D::Error::custom</span>(<span class="string">&quot;could not parse string&quot;</span>))
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Deserialize</span>, <span class="ident">Serialize</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">Query</span> {
    <span class="ident">a</span>: <span class="ident">u8</span>,
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">flatten</span>)]</span>
    <span class="ident">common</span>: <span class="ident">CommonParams</span>,
}

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Deserialize</span>, <span class="ident">Serialize</span>, <span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">struct</span> <span class="ident">CommonParams</span> {
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">deserialize_with</span><span class="op">=</span><span class="string">&quot;from_str&quot;</span>)]</span>
    <span class="ident">limit</span>: <span class="ident">u64</span>,
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">deserialize_with</span><span class="op">=</span><span class="string">&quot;from_str&quot;</span>)]</span>
    <span class="ident">offset</span>: <span class="ident">u64</span>,
    <span class="attribute">#[<span class="ident">serde</span>(<span class="ident">deserialize_with</span><span class="op">=</span><span class="string">&quot;from_str&quot;</span>)]</span>
    <span class="ident">remaining</span>: <span class="ident">bool</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">params</span> <span class="op">=</span> <span class="string">&quot;a=1&amp;limit=100&amp;offset=50&amp;remaining=true&quot;</span>;
    <span class="kw">let</span> <span class="ident">query</span> <span class="op">=</span> <span class="ident">Query</span> { <span class="ident">a</span>: <span class="number">1</span>, <span class="ident">common</span>: <span class="ident">CommonParams</span> { <span class="ident">limit</span>: <span class="number">100</span>, <span class="ident">offset</span>: <span class="number">50</span>, <span class="ident">remaining</span>: <span class="bool-val">true</span> } };
    <span class="kw">let</span> <span class="ident">rec_query</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Query</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">qs::from_str</span>(<span class="ident">params</span>);
    <span class="macro">assert_eq!</span>(<span class="ident">rec_query</span>.<span class="ident">unwrap</span>(), <span class="ident">query</span>);
}</code></pre></div>
<h3 id="use-with-actix_web-extractors" class="section-header"><a href="#use-with-actix_web-extractors">Use with <code>actix_web</code> extractors</a></h3>
<p>The <code>actix</code> feature enables the use of <code>serde_qs::actix::QsQuery</code>, which
is a direct substitute for the <code>actix_web::Query</code> and can be used as an extractor:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">fn</span> <span class="ident">index</span>(<span class="ident">info</span>: <span class="ident">QsQuery</span><span class="op">&lt;</span><span class="ident">Info</span><span class="op">&gt;</span>) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> {
    <span class="prelude-val">Ok</span>(<span class="macro">format!</span>(<span class="string">&quot;Welcome {}!&quot;</span>, <span class="ident">info</span>.<span class="ident">username</span>))
}</code></pre></div>
<p>Support for <code>actix-web 2.0.0</code> is available via the <code>actix2</code> feature.</p>
<h3 id="use-with-warp-filters" class="section-header"><a href="#use-with-warp-filters">Use with <code>warp</code> filters</a></h3>
<p>The <code>warp</code> feature enables the use of <code>serde_qs::warp::query()</code>, which
is a substitute for the <code>warp::query::query()</code> filter and can be used like this:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="ident">serde_qs::warp::query</span>(<span class="ident">Config::default</span>())
    .<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">info</span><span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> {
        <span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">Rejection</span><span class="op">&gt;</span>(<span class="macro">format!</span>(<span class="string">&quot;Welcome {}!&quot;</span>, <span class="ident">info</span>.<span class="ident">username</span>))
    })
    .<span class="ident">recover</span>(<span class="ident">serde_qs::warp::recover_fn</span>);</code></pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Config.html" title="serde_qs::Config struct">Config</a></div><div class="item-right docblock-short"><p>To override the default serialization parameters, first construct a new
Config.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.QsSerializer.html" title="serde_qs::QsSerializer struct">QsSerializer</a></div><div class="item-right docblock-short"><p>A serializer for the querystring format.</p>
</div></div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="serde_qs::Error enum">Error</a></div><div class="item-right docblock-short"><p>Error type for <code>serde_qs</code>.</p>
</div></div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_bytes.html" title="serde_qs::from_bytes fn">from_bytes</a></div><div class="item-right docblock-short"><p>Deserializes a querystring from a <code>&amp;[u8]</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_str.html" title="serde_qs::from_str fn">from_str</a></div><div class="item-right docblock-short"><p>Deserializes a querystring from a <code>&amp;str</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_string.html" title="serde_qs::to_string fn">to_string</a></div><div class="item-right docblock-short"><p>Serializes a value into a querystring.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.to_writer.html" title="serde_qs::to_writer fn">to_writer</a></div><div class="item-right docblock-short"><p>Serializes a value into a generic writer object.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="serde_qs" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>