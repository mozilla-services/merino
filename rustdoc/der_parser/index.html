<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="License: MIT Apache License 2.0 docs.rs crates.io Download numbers dependency status Github CI Minimum rustc version"><meta name="keywords" content="rust, rustlang, rust-lang, der_parser"><title>der_parser - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../der_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../der_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate der_parser</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 6.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="der_parser" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../der_parser/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">der_parser</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/der_parser/lib.rs.html#1-294">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="./LICENSE-MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT" /></a>
<a href="./LICENSE-APACHE"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="Apache License 2.0" /></a>
<a href="https://docs.rs/der-parser"><img src="https://docs.rs/der-parser/badge.svg" alt="docs.rs" /></a>
<a href="https://crates.io/crates/der-parser"><img src="https://img.shields.io/crates/v/der-parser.svg" alt="crates.io" /></a>
<a href="https://crates.io/crates/der-parser"><img src="https://img.shields.io/crates/d/der-parser.svg" alt="Download numbers" /></a>
<a href="https://deps.rs/crate/der-parser/5.0.1"><img src="https://deps.rs/crate/der-parser/5.0.0/status.svg" alt="dependency status" /></a>
<a href="https://github.com/rusticata/der-parser/actions"><img src="https://github.com/rusticata/der-parser/workflows/Continuous%20integration/badge.svg" alt="Github CI" /></a>
<a href="#rust-version-requirements"><img src="https://img.shields.io/badge/rustc-1.48.0+-lightgray.svg" alt="Minimum rustc version" /></a></p>
<h2 id="berder-parser"><a href="#berder-parser">BER/DER Parser</a></h2>
<p>A parser for Basic Encoding Rules (BER [<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
   Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
   (DER).">X.690</a>]) and Distinguished Encoding Rules(DER
[<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
   Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
   (DER).">X.690</a>]), implemented with the <a href="https://github.com/Geal/nom">nom</a> parser combinator
framework.</p>
<p>It is written in pure Rust, fast, and makes extensive use of zero-copy. A lot of care is taken
to ensure security and safety of this crate, including design (recursion limit, defensive
programming), tests, and fuzzing. It also aims to be panic-free.</p>
<p>Historically, this parser was intended for DER only, and BER support was added later. This may
still reflect on some naming schemes, but has no other consequence: the <code>BerObject</code> and
<code>DerObject</code> used in this crate are type aliases, so all functions are compatible.</p>
<p>DER parsing functions have additional constraints verification, however.</p>
<p>Serialization has also been added (see <a href="#serialization">Serialization</a> )</p>
<p>The code is available on <a href="https://github.com/rusticata/der-parser">Github</a>
and is part of the <a href="https://github.com/rusticata">Rusticata</a> project.</p>
<h2 id="berder-parsers"><a href="#berder-parsers">BER/DER parsers</a></h2>
<p>BER stands for Basic Encoding Rules, and is defined in <a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
   Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
   (DER).">X.690</a>. It defines a set of rules to
encode and decode ASN.1 objects in binary.</p>
<p><a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
   Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
   (DER).">X.690</a> also defines Distinguished Encoding Rules (DER), which is BER with added rules to
ensure canonical and unequivocal binary representation of objects.</p>
<p>The choice of which one to use is usually guided by the speficication of the data format based
on BER or DER: for example, X.509 uses DER as encoding representation.</p>
<p>See the related modules for object definitions, functions, and example:</p>
<ul>
<li><a href="ber/index.html" title="ber"><code>ber</code></a>: Basic Encoding Rules</li>
<li><a href="der/index.html" title="der"><code>der</code></a>: Distinguished Encoding Rules</li>
</ul>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<p>Parse two BER integers (see <a href="#berder-integers">BER/DER Integers</a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">der_parser::ber::parse_ber_integer</span>;

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> [ <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let</span> (<span class="ident">rem</span>, <span class="ident">obj1</span>) <span class="op">=</span> <span class="ident">parse_ber_integer</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>).<span class="ident">expect</span>(<span class="string">&quot;parsing failed&quot;</span>);
<span class="kw">let</span> (<span class="ident">rem</span>, <span class="ident">obj2</span>) <span class="op">=</span> <span class="ident">parse_ber_integer</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>).<span class="ident">expect</span>(<span class="string">&quot;parsing failed&quot;</span>);</code></pre></div>
<p>Parse a DER sequence of integers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">der_parser::der</span>::{<span class="ident">parse_der_integer</span>, <span class="ident">parse_der_sequence_of</span>};

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> [ <span class="number">0x30</span>, <span class="number">0x0a</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let</span> (<span class="ident">rem</span>, <span class="ident">seq</span>) <span class="op">=</span> <span class="ident">parse_der_sequence_of</span>(<span class="ident">parse_der_integer</span>)(<span class="kw-2">&amp;</span><span class="ident">bytes</span>)
                    .<span class="ident">expect</span>(<span class="string">&quot;parsing failed&quot;</span>);</code></pre></div>
<p>Note: all parsing functions return the remaining (unparsed) bytes and the parsed object, or an
error.</p>
<h2 id="der-parser-design"><a href="#der-parser-design">DER parser design</a></h2>
<p>Parsing functions are inspired from <code>nom</code>, and follow the same interface. The most common
return type is <a href="error/type.BerResult.html"><code>BerResult</code></a>, that stores the remaining bytes and
parsed <a href="ber/struct.BerObject.html"><code>BerObject</code></a>, or an error. Reading the nom documentation may
help understanding how to write parsers and use the output.</p>
<p>There are two different approaches for parsing DER objects: reading the objects recursively as
long as the tags are known, or specifying a description of the expected objects (generally from
the <a href="http://www.itu.int/rec/T-REC-X.680/en" title="Abstract Syntax Notation One (ASN.1):
   Specification of basic notation.">ASN.1</a> description).</p>
<p>The first parsing method can be done using the <a href="ber/fn.parse_ber.html"><code>parse_ber</code></a> and
<a href="der/fn.parse_der.html"><code>parse_der</code></a> methods.
It is useful when decoding an arbitrary DER object.
However, it cannot fully parse all objects, especially those containing IMPLICIT, OPTIONAL, or
DEFINED BY items.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">der_parser::parse_der</span>;

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> [ <span class="number">0x30</span>, <span class="number">0x0a</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let</span> <span class="ident">parsed</span> <span class="op">=</span> <span class="ident">parse_der</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>);</code></pre></div>
<p>The second (and preferred) parsing method is to specify the expected objects recursively. The
following functions can be used:</p>
<ul>
<li><a href="ber/fn.parse_ber_sequence_defined.html"><code>parse_ber_sequence_defined</code></a> and similar functions
for sequences and sets variants</li>
<li><a href="ber/fn.parse_ber_tagged_explicit.html"><code>parse_ber_tagged_explicit</code></a> for tagged explicit</li>
<li><a href="ber/fn.parse_ber_tagged_implicit.html"><code>parse_ber_tagged_implicit</code></a> for tagged implicit</li>
<li><a href="ber/fn.parse_ber_container.html"><code>parse_ber_container</code></a> for generic parsing, etc.</li>
<li>DER objects use the <code>_der_</code> variants</li>
</ul>
<p>For example, to read a BER sequence containing two integers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">der_parser::ber</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">der_parser::error::BerResult</span>;

<span class="kw">fn</span> <span class="ident">localparse_seq</span>(<span class="ident">i</span>:<span class="kw-2">&amp;</span>[<span class="ident">u8</span>]) -&gt; <span class="ident">BerResult</span> {
    <span class="ident">parse_ber_sequence_defined</span>(<span class="op">|</span><span class="ident">data</span><span class="op">|</span> {
        <span class="kw">let</span> (<span class="ident">rem</span>, <span class="ident">a</span>) <span class="op">=</span> <span class="ident">parse_ber_integer</span>(<span class="ident">data</span>)<span class="question-mark">?</span>;
        <span class="kw">let</span> (<span class="ident">rem</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">parse_ber_integer</span>(<span class="ident">rem</span>)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>((<span class="ident">rem</span>, <span class="macro">vec!</span>[<span class="ident">a</span>, <span class="ident">b</span>]))
    })(<span class="ident">i</span>)
}

<span class="kw">let</span> <span class="ident">bytes</span> <span class="op">=</span> [ <span class="number">0x30</span>, <span class="number">0x0a</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,
              <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
];

<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">parsed</span>) <span class="op">=</span> <span class="ident">localparse_seq</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>).<span class="ident">expect</span>(<span class="string">&quot;parsing failed&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">parsed</span>[<span class="number">0</span>].<span class="ident">as_u64</span>(), <span class="prelude-val">Ok</span>(<span class="number">65537</span>));
<span class="macro">assert_eq!</span>(<span class="ident">parsed</span>[<span class="number">1</span>].<span class="ident">as_u64</span>(), <span class="prelude-val">Ok</span>(<span class="number">65536</span>));</code></pre></div>
<p>All functions return a <a href="error/type.BerResult.html"><code>BerResult</code></a> object: the parsed
<a href="ber/struct.BerObject.html"><code>BerObject</code></a>, an <code>Incomplete</code> value, or an error.</p>
<p>Note that this type is also a <code>Result</code>, so usual functions (<code>map</code>, <code>unwrap</code> etc.) are available.</p>
<h2 id="notes"><a href="#notes">Notes</a></h2><h3 id="berder-integers"><a href="#berder-integers">BER/DER Integers</a></h3>
<p>DER integers can be of any size, so it is not possible to store them as simple integers (they
are stored as raw bytes).</p>
<p>Note that, by default, BER/DER integers are signed. Functions are provided to request reading
unsigned values, but they will fail if the integer value is negative.</p>
<p>To get the integer value for all possible integer sign and size, use
<a href="ber/struct.BerObject.html#method.as_bigint"><code>BerObject::as_bigint</code></a>) (requires the <code>bigint</code> feature).</p>
<p>To get a simple value expected to be in a known range, use methods like
<a href="ber/struct.BerObject.html#method.as_i32"><code>BerObject::as_i32</code></a>) and
<a href="ber/struct.BerObject.html#method.as_i64"><code>BerObject::as_i64</code></a> (or the unsigned versions
<a href="ber/struct.BerObject.html#method.as_u32"><code>BerObject::as_u32</code></a> and
<a href="ber/struct.BerObject.html#method.as_u64"><code>BerObject::as_u64</code></a>
),
which will return the value, or an error if the integer is too large (or is negative).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">der_parser::ber</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>];

<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">object</span>) <span class="op">=</span> <span class="ident">parse_ber_integer</span>(<span class="ident">data</span>).<span class="ident">expect</span>(<span class="string">&quot;parsing failed&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="ident">object</span>.<span class="ident">as_u64</span>(), <span class="prelude-val">Ok</span>(<span class="number">65537</span>));

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;bigint&quot;</span>)]</span>
<span class="macro">assert_eq!</span>(<span class="ident">object</span>.<span class="ident">as_bigint</span>(), <span class="prelude-val">Ok</span>(<span class="number">65537</span>.<span class="ident">into</span>()))</code></pre></div>
<p>Access to the raw value is possible using the <code>as_slice</code> method.</p>
<h3 id="parsers-combinators-macros"><a href="#parsers-combinators-macros">Parsers, combinators, macros</a></h3>
<p>Some parsing tools (for ex for tagged objects) are available in different forms:</p>
<ul>
<li>parsers: (regular) functions that takes input and create an object</li>
<li>combinators: functions that takes parsers (or combinators) as input, and return a function
(usually, the parser). They are used (combined) as building blocks to create more complex
parsers.</li>
<li>macros: these are generally previous (historic) versions of parsers, kept for compatibility.
They can sometime reduce the amount of code to write, but are hard to debug.
Parsers should be preferred when possible.</li>
</ul>
<h3 id="misc-notes"><a href="#misc-notes">Misc Notes</a></h3>
<ul>
<li>The DER constraints are verified if using <code>parse_der</code>.</li>
<li><code>BerObject</code> and <code>DerObject</code> are the same objects (type alias). The only difference is the
verification of constraints <em>during parsing</em>.</li>
</ul>
<h3 id="rust-version-requirements"><a href="#rust-version-requirements">Rust version requirements</a></h3>
<p>The 6.0 series of <code>der-parser</code> requires <strong>Rustc version 1.48 or greater</strong>, based on nom 7
dependencies.</p>
<h2 id="serialization"><a href="#serialization">Serialization</a></h2>
<p>Support for encoding BER/DER objects is currently being tested and can be used by activating the <code>serialize</code> feature.
Note that current status is <strong>experimental</strong>.</p>
<p>See the <code>ber_encode_*</code> functions in the <a href="ber/index.html"><code>ber</code></a> module, and
<a href="ber/struct.BerObject.html#method.to_vec"><code>BerObject::to_vec</code></a></p>
<h2 id="references"><a href="#references">References</a></h2>
<ul>
<li>[<a href="http://www.itu.int/rec/T-REC-X.680/en" title="Abstract Syntax Notation One (ASN.1):
   Specification of basic notation.">X.680</a>] Abstract Syntax Notation One (ASN.1): Specification of basic notation.</li>
<li>[<a href="https://www.itu.int/rec/T-REC-X.690/en" title="ASN.1 encoding rules: Specification of
   Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules
   (DER).">X.690</a>] ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical
Encoding Rules (CER) and Distinguished Encoding Rules (DER).</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left import-item" id="reexport.nom"><code>pub use <a class="mod" href="../nom/index.html" title="mod nom">nom</a>;</code></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left import-item" id="reexport.num_bigint"><code>pub use <a class="mod" href="../num_bigint/index.html" title="mod num_bigint">num_bigint</a>;</code></div><div class="item-right docblock-short"></div></div></div><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="ber/index.html" title="der_parser::ber mod">ber</a></div><div class="item-right docblock-short"><p>Basic Encoding Rules (BER) objects and parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="der/index.html" title="der_parser::der mod">der</a></div><div class="item-right docblock-short"><p>Distinguished Encoding Rules (DER) objects and parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="error/index.html" title="der_parser::error mod">error</a></div><div class="item-right docblock-short"><p>Error type for BER/DER parsers</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="oid/index.html" title="der_parser::oid mod">oid</a></div><div class="item-right docblock-short"><p>Object ID (OID) representations.</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.oid.html" title="der_parser::oid macro">oid</a></div><div class="item-right docblock-short"><p>Procedural macro to get encoded oids, see the <a href="oid/index.html">oid module</a>.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_ber.html" title="der_parser::parse_ber fn">parse_ber</a></div><div class="item-right docblock-short"><p>Parse BER object recursively</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_der.html" title="der_parser::parse_der fn">parse_der</a></div><div class="item-right docblock-short"><p>Parse DER object recursively</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.IResult.html" title="der_parser::IResult type">IResult</a></div><div class="item-right docblock-short"><p>Holds the result of parsing functions</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="der_parser" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>