window.SIDEBAR_ITEMS = {"enum":[["Either",""]],"fn":[["and_then","Equivalent to `p.and_then(f)`."],["any_partial_state","Returns a parser where `P::PartialState` is boxed. Useful as a way to avoid writing the type since it can get very large after combining a few parsers."],["any_send_partial_state","Returns a parser where `P::PartialState` is boxed. Useful as a way to avoid writing the type since it can get very large after combining a few parsers."],["any_send_sync_partial_state","Returns a parser where `P::PartialState` is boxed. Useful as a way to avoid writing the type since it can get very large after combining a few parsers."],["attempt","`attempt(p)` behaves as `p` except it always acts as `p` peeked instead of committed on its parse."],["factory","Constructs the parser lazily on each `parse_*` call. This is similar to `lazy` but it takes `Input` as an argument and allows different parsers to be returned on each call to `p` while still reporting the correct errors."],["flat_map","Equivalent to `p.flat_map(f)`."],["from_str","Takes a parser that outputs a string like value (`&str`, `String`, `&[u8]` or `Vec<u8>`) and parses it using `std::str::FromStr`. Errors if the output of `parser` is not UTF-8 or if `FromStr::from_str` returns an error."],["input_converter",""],["lazy","Constructs the parser lazily on each `parse_*` call. Can be used to effectively reduce the size of deeply nested parsers as only the function producing the parser is stored."],["look_ahead","`look_ahead(p)` acts as `p` but doesnâ€™t consume input on success."],["map","Equivalent to `p.map(f)`."],["map_input","Equivalent to `p.map_input(f)`."],["no_partial",""],["not_followed_by","Succeeds only if `parser` fails. Never consumes any input."],["opaque","Creates a parser from a function which takes a function that are given the actual parser. Though convoluted this makes it possible to hide the concrete parser type without `Box` or losing the full information about the parser as is the case of `parser`."],["recognize","Constructs a parser which returns the tokens parsed by `parser` accumulated in `F: Extend<Input::Token>` instead of `P::Output`."],["spanned","Equivalent to `p.spanned()`."]],"struct":[["AndThen",""],["AnyPartialState",""],["AnyPartialStateParser",""],["AnySendPartialState",""],["AnySendPartialStateParser",""],["AnySendSyncPartialState",""],["AnySendSyncPartialStateParser",""],["Factory",""],["FlatMap",""],["FromStr",""],["Ignore",""],["InputConverter",""],["Lazy",""],["LookAhead",""],["Map",""],["MapInput",""],["NoPartial",""],["NotFollowedBy",""],["Opaque",""],["Recognize",""],["Spanned",""],["Try",""]],"trait":[["Converter",""],["StrLike",""]],"type":[["FnOpaque","Alias over `Opaque` where the function can be a plain function pointer (does not need to capture any values)"]]};