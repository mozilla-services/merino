<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate contains parser combinators, roughly based on the Haskell libraries parsec and attoparsec."><meta name="keywords" content="rust, rustlang, rust-lang, combine"><title>combine - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../combine/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../combine/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate combine</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 4.6.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="combine" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../combine/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">combine</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/combine/lib.rs.html#1-1006">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate contains parser combinators, roughly based on the Haskell libraries
<a href="http://hackage.haskell.org/package/parsec">parsec</a> and
<a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a>.</p>
<p>A parser in this library can be described as a function which takes some input and if it
is successful, returns a value together with the remaining input.
A parser combinator is a function which takes one or more parsers and returns a new parser.
For instance the <a href="parser/repeat/fn.many.html"><code>many</code></a> parser can be used to convert a parser for single digits into one that
parses multiple digits. By modeling parsers in this way it becomes easy to compose complex
parsers in an almost declarative way.</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p><code>combine</code> limits itself to creating <a href="https://en.wikipedia.org/wiki/LL_parser">LL(1) parsers</a>
(it is possible to opt-in to LL(k) parsing using the <a href="parser/combinator/fn.attempt.html"><code>attempt</code></a> combinator) which makes the
parsers easy to reason about in both function and performance while sacrificing
some generality. In addition to you being able to reason better about the parsers you
construct <code>combine</code> the library also takes the knowledge of being an LL parser and uses it to
automatically construct good error messages.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">combine</span>;
<span class="kw">use</span> <span class="ident">combine</span>::{<span class="ident">Parser</span>, <span class="ident">EasyParser</span>};
<span class="kw">use</span> <span class="ident">combine::stream::position</span>;
<span class="kw">use</span> <span class="ident">combine::parser::char</span>::{<span class="ident">digit</span>, <span class="ident">letter</span>};
<span class="kw">const</span> <span class="ident">MSG</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span> <span class="op">=</span> <span class="string">r#&quot;Parse error at line: 1, column: 1
Unexpected `|`
Expected `digit` or `letter`
&quot;#</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">// Wrapping a `&amp;str` with `State` provides automatic line and column tracking. If `State`</span>
    <span class="comment">// was not used the positions would instead only be pointers into the `&amp;str`</span>
    <span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Err</span>(<span class="ident">err</span>) <span class="op">=</span> <span class="ident">digit</span>().<span class="ident">or</span>(<span class="ident">letter</span>()).<span class="ident">easy_parse</span>(<span class="ident">position::Stream::new</span>(<span class="string">&quot;|&quot;</span>)) {
        <span class="macro">assert_eq!</span>(<span class="ident">MSG</span>, <span class="macro">format!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">err</span>));
    }
}</code></pre></div>
<p>This library is currently split into a few core modules:</p>
<ul>
<li>
<p><a href="parser/index.html"><code>parser</code></a> is where you will find all the parsers that combine provides. It contains the core
<a href="parser/trait.Parser.html"><code>Parser</code></a> trait as well as several submodules such as <code>sequence</code> or <code>choice</code> which each
contain several parsers aimed at a specific niche.</p>
</li>
<li>
<p><a href="stream/trait.Stream.html"><code>stream</code></a> contains the second most important trait next to <a href="parser/trait.Parser.html"><code>Parser</code></a>. Streams represent the
data source which is being parsed such as <code>&amp;[u8]</code>, <code>&amp;str</code> or iterators.</p>
</li>
<li>
<p><a href="easy/index.html"><code>easy</code></a> contains combine’s default “easy” error and stream handling. If you use the
<code>easy_parse</code> method to start your parsing these are the types that are used.</p>
</li>
<li>
<p><a href="error/index.html"><code>error</code></a> contains the types and traits that make up combine’s error handling. Unless you
need to customize the errors your parsers return you should not need to use this module much.</p>
</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">combine</span>;
<span class="kw">use</span> <span class="ident">combine::parser::char</span>::{<span class="ident">spaces</span>, <span class="ident">digit</span>, <span class="ident">char</span>};
<span class="kw">use</span> <span class="ident">combine</span>::{<span class="ident">many1</span>, <span class="ident">sep_by</span>, <span class="ident">Parser</span>, <span class="ident">EasyParser</span>};
<span class="kw">use</span> <span class="ident">combine::stream::easy</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="comment">//Parse spaces first and use the with method to only keep the result of the next parser</span>
    <span class="kw">let</span> <span class="ident">integer</span> <span class="op">=</span> <span class="ident">spaces</span>()
        <span class="comment">//parse a string of digits into an i32</span>
        .<span class="ident">with</span>(<span class="ident">many1</span>(<span class="ident">digit</span>()).<span class="ident">map</span>(<span class="op">|</span><span class="ident">string</span>: <span class="ident">String</span><span class="op">|</span> <span class="ident">string</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>().<span class="ident">unwrap</span>()));

    <span class="comment">//Parse integers separated by commas, skipping whitespace</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">integer_list</span> <span class="op">=</span> <span class="ident">sep_by</span>(<span class="ident">integer</span>, <span class="ident">spaces</span>().<span class="ident">skip</span>(<span class="ident">char</span>(<span class="string">&#39;,&#39;</span>)));

    <span class="comment">//Call parse with the input to execute the parser</span>
    <span class="kw">let</span> <span class="ident">input</span> <span class="op">=</span> <span class="string">&quot;1234, 45,78&quot;</span>;
    <span class="kw">let</span> <span class="ident">result</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="ident">str</span>), <span class="ident">easy::ParseError</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">=</span>
        <span class="ident">integer_list</span>.<span class="ident">easy_parse</span>(<span class="ident">input</span>);
    <span class="kw">match</span> <span class="ident">result</span> {
        <span class="prelude-val">Ok</span>((<span class="ident">value</span>, <span class="ident">_remaining_input</span>)) =&gt; <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">value</span>),
        <span class="prelude-val">Err</span>(<span class="ident">err</span>) =&gt; <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">err</span>)
    }
}</code></pre></div>
<p>If we need a parser that is mutually recursive or if we want to export a reusable parser the
<a href="macro.parser.html"><code>parser!</code></a> macro can be used. In effect it makes it possible to return a parser without naming
the type of the parser (which can be very large due to combine’s trait based approach). While
it is possible to do avoid naming the type without the macro those solutions require either allocation
(<code>Box&lt;dyn Parser&lt; Input, Output = O, PartialState = P&gt;&gt;</code>) or nightly rust via <code>impl Trait</code>. The
macro thus threads the needle and makes it possible to have non-allocating, anonymous parsers
on stable rust.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">combine</span>;
<span class="kw">use</span> <span class="ident">combine::parser::char</span>::{<span class="ident">char</span>, <span class="ident">letter</span>, <span class="ident">spaces</span>};
<span class="kw">use</span> <span class="ident">combine</span>::{<span class="ident">between</span>, <span class="ident">choice</span>, <span class="ident">many1</span>, <span class="ident">parser</span>, <span class="ident">sep_by</span>, <span class="ident">Parser</span>, <span class="ident">EasyParser</span>};
<span class="kw">use</span> <span class="ident">combine::error</span>::{<span class="ident">ParseError</span>, <span class="ident">StdParseResult</span>};
<span class="kw">use</span> <span class="ident">combine::stream</span>::{<span class="ident">Stream</span>, <span class="ident">Positioned</span>};
<span class="kw">use</span> <span class="ident">combine::stream::position</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>)]</span>
<span class="kw">pub</span> <span class="kw">enum</span> <span class="ident">Expr</span> {
    <span class="ident">Id</span>(<span class="ident">String</span>),
    <span class="ident">Array</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Expr</span><span class="op">&gt;</span>),
    <span class="ident">Pair</span>(<span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Expr</span><span class="op">&gt;</span>, <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">Expr</span><span class="op">&gt;</span>)
}

<span class="comment">// `impl Parser` can be used to create reusable parsers with zero overhead</span>
<span class="kw">fn</span> <span class="ident">expr_</span><span class="op">&lt;</span><span class="ident">Input</span><span class="op">&gt;</span>() -&gt; <span class="kw">impl</span> <span class="ident">Parser</span><span class="op">&lt;</span> <span class="ident">Input</span>, <span class="ident">Output</span> <span class="op">=</span> <span class="ident">Expr</span><span class="op">&gt;</span>
    <span class="kw">where</span> <span class="ident">Input</span>: <span class="ident">Stream</span><span class="op">&lt;</span><span class="ident">Token</span> <span class="op">=</span> <span class="ident">char</span><span class="op">&gt;</span>,
          <span class="comment">// Necessary due to rust-lang/rust#24159</span>
          <span class="ident">Input::Error</span>: <span class="ident">ParseError</span><span class="op">&lt;</span><span class="ident">Input::Token</span>, <span class="ident">Input::Range</span>, <span class="ident">Input::Position</span><span class="op">&gt;</span>,
{
    <span class="kw">let</span> <span class="ident">word</span> <span class="op">=</span> <span class="ident">many1</span>(<span class="ident">letter</span>());

    <span class="comment">// A parser which skips past whitespace.</span>
    <span class="comment">// Since we aren&#39;t interested in knowing that our expression parser</span>
    <span class="comment">// could have accepted additional whitespace between the tokens we also silence the error.</span>
    <span class="kw">let</span> <span class="ident">skip_spaces</span> <span class="op">=</span> <span class="op">|</span><span class="op">|</span> <span class="ident">spaces</span>().<span class="ident">silent</span>();

    <span class="comment">//Creates a parser which parses a char and skips any trailing whitespace</span>
    <span class="kw">let</span> <span class="ident">lex_char</span> <span class="op">=</span> <span class="op">|</span><span class="ident">c</span><span class="op">|</span> <span class="ident">char</span>(<span class="ident">c</span>).<span class="ident">skip</span>(<span class="ident">skip_spaces</span>());

    <span class="kw">let</span> <span class="ident">comma_list</span> <span class="op">=</span> <span class="ident">sep_by</span>(<span class="ident">expr</span>(), <span class="ident">lex_char</span>(<span class="string">&#39;,&#39;</span>));
    <span class="kw">let</span> <span class="ident">array</span> <span class="op">=</span> <span class="ident">between</span>(<span class="ident">lex_char</span>(<span class="string">&#39;[&#39;</span>), <span class="ident">lex_char</span>(<span class="string">&#39;]&#39;</span>), <span class="ident">comma_list</span>);

    <span class="comment">//We can use tuples to run several parsers in sequence</span>
    <span class="comment">//The resulting type is a tuple containing each parsers output</span>
    <span class="kw">let</span> <span class="ident">pair</span> <span class="op">=</span> (<span class="ident">lex_char</span>(<span class="string">&#39;(&#39;</span>),
                <span class="ident">expr</span>(),
                <span class="ident">lex_char</span>(<span class="string">&#39;,&#39;</span>),
                <span class="ident">expr</span>(),
                <span class="ident">lex_char</span>(<span class="string">&#39;)&#39;</span>))
                   .<span class="ident">map</span>(<span class="op">|</span><span class="ident">t</span><span class="op">|</span> <span class="ident">Expr::Pair</span>(<span class="ident">Box::new</span>(<span class="ident">t</span>.<span class="number">1</span>), <span class="ident">Box::new</span>(<span class="ident">t</span>.<span class="number">3</span>)));

    <span class="ident">choice</span>((
        <span class="ident">word</span>.<span class="ident">map</span>(<span class="ident">Expr::Id</span>),
        <span class="ident">array</span>.<span class="ident">map</span>(<span class="ident">Expr::Array</span>),
        <span class="ident">pair</span>,
    ))
        .<span class="ident">skip</span>(<span class="ident">skip_spaces</span>())
}

<span class="comment">// As this expression parser needs to be able to call itself recursively `impl Parser` can&#39;t</span>
<span class="comment">// be used on its own as that would cause an infinitely large type. We can avoid this by using</span>
<span class="comment">// the `parser!` macro which erases the inner type and the size of that type entirely which</span>
<span class="comment">// lets it be used recursively.</span>
<span class="comment">//</span>
<span class="comment">// (This macro does not use `impl Trait` which means it can be used in rust &lt; 1.26 as well to</span>
<span class="comment">// emulate `impl Parser`)</span>
<span class="macro">parser!</span>{
    <span class="kw">fn</span> <span class="ident">expr</span>[<span class="ident">Input</span>]()(<span class="ident">Input</span>) -&gt; <span class="ident">Expr</span>
    <span class="kw">where</span> [<span class="ident">Input</span>: <span class="ident">Stream</span><span class="op">&lt;</span><span class="ident">Token</span> <span class="op">=</span> <span class="ident">char</span><span class="op">&gt;</span>]
    {
        <span class="ident">expr_</span>()
    }
}

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">expr</span>()
        .<span class="ident">parse</span>(<span class="string">&quot;[[], (hello, world), [rust]]&quot;</span>);
    <span class="kw">let</span> <span class="ident">expr</span> <span class="op">=</span> <span class="ident">Expr::Array</span>(<span class="macro">vec!</span>[
          <span class="ident">Expr::Array</span>(<span class="ident">Vec::new</span>())
        , <span class="ident">Expr::Pair</span>(<span class="ident">Box::new</span>(<span class="ident">Expr::Id</span>(<span class="string">&quot;hello&quot;</span>.<span class="ident">to_string</span>())),
                     <span class="ident">Box::new</span>(<span class="ident">Expr::Id</span>(<span class="string">&quot;world&quot;</span>.<span class="ident">to_string</span>())))
        , <span class="ident">Expr::Array</span>(<span class="macro">vec!</span>[<span class="ident">Expr::Id</span>(<span class="string">&quot;rust&quot;</span>.<span class="ident">to_string</span>())])
    ]);
    <span class="macro">assert_eq!</span>(<span class="ident">result</span>, <span class="prelude-val">Ok</span>((<span class="ident">expr</span>, <span class="string">&quot;&quot;</span>)));
}</code></pre></div>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="easy/index.html" title="combine::easy mod">easy</a></div><div class="item-right docblock-short"><p>Stream wrapper which provides an informative and easy to use error type.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="error/index.html" title="combine::error mod">error</a></div><div class="item-right docblock-short"><p>Error types and traits which define what kind of errors combine parsers may emit</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="parser/index.html" title="combine::parser mod">parser</a></div><div class="item-right docblock-short"><p>A collection of both concrete parsers as well as parser combinators.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="stream/index.html" title="combine::stream mod">stream</a></div><div class="item-right docblock-short"><p>Streams are similar to the <code>Iterator</code> trait in that they represent some sequential set of items
which can be retrieved one by one. Where <code>Stream</code>s differ is that they are allowed to return
errors instead of just <code>None</code> and if they implement the <code>RangeStreamOnce</code> trait they are also
capable of returning multiple items at the same time, usually in the form of a slice.</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.choice.html" title="combine::choice macro">choice</a></div><div class="item-right docblock-short"><p>Takes a number of parsers and tries to apply them each in order.
Fails if all the parsers fails or if an applied parser fails after it has committed to its
parse.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.decode.html" title="combine::decode macro">decode</a></div><div class="item-right docblock-short"><p>Parses an instance of <code>std::io::Read</code> as a <code>&amp;[u8]</code> without reading the entire file into
memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.decode_tokio.html" title="combine::decode_tokio macro">decode_tokio</a></div><div class="item-right docblock-short"><p>Parses an instance of <code>tokio::io::AsyncRead</code> as a <code>&amp;[u8]</code> without reading the entire file into
memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.dispatch.html" title="combine::dispatch macro">dispatch</a></div><div class="item-right docblock-short"><p><code>dispatch!</code> allows a parser to be constructed depending on earlier input, without forcing each
branch to have the same type of parser</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.opaque.html" title="combine::opaque macro">opaque</a></div><div class="item-right docblock-short"><p>Convenience macro over <a href="parser/combinator/fn.opaque.html"><code>opaque</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.parser.html" title="combine::parser macro">parser</a></div><div class="item-right docblock-short"><p>Declares a named parser which can easily be reused.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.struct_parser.html" title="combine::struct_parser macro">struct_parser</a></div><div class="item-right docblock-short"><p>Sequences multiple parsers and builds a struct out of them.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ParseResult.html" title="combine::ParseResult enum">ParseResult</a></div><div class="item-right docblock-short"><p>A <code>Result</code> type which has the committed status flattened into the result.
Conversions to and from <code>std::result::Result</code> can be done using <code>result.into()</code> or
<code>From::from(result)</code></p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EasyParser.html" title="combine::EasyParser trait">EasyParser</a></div><div class="item-right docblock-short"><p>Provides the <code>easy_parse</code> method which provides good error messages by default</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.ParseError.html" title="combine::ParseError trait">ParseError</a></div><div class="item-right docblock-short"><p>Trait which defines a combine parse error.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Parser.html" title="combine::Parser trait">Parser</a></div><div class="item-right docblock-short"><p>By implementing the <code>Parser</code> trait a type says that it can be used to parse an input stream
into the type <code>Output</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Positioned.html" title="combine::Positioned trait">Positioned</a></div><div class="item-right docblock-short"><p>A type which has a position.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.RangeStream.html" title="combine::RangeStream trait">RangeStream</a></div><div class="item-right docblock-short"><p>A <code>RangeStream</code> is an extension of <code>Stream</code> which allows for zero copy parsing.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.RangeStreamOnce.html" title="combine::RangeStreamOnce trait">RangeStreamOnce</a></div><div class="item-right docblock-short"><p>A <code>RangeStream</code> is an extension of <code>StreamOnce</code> which allows for zero copy parsing.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Stream.html" title="combine::Stream trait">Stream</a></div><div class="item-right docblock-short"><p>A stream of tokens which can be duplicated</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.StreamOnce.html" title="combine::StreamOnce trait">StreamOnce</a></div><div class="item-right docblock-short"><p><code>StreamOnce</code> represents a sequence of items that can be extracted one by one.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.any.html" title="combine::any fn">any</a></div><div class="item-right docblock-short"><p>Parses any token.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.attempt.html" title="combine::attempt fn">attempt</a></div><div class="item-right docblock-short"><p><code>attempt(p)</code> behaves as <code>p</code> except it always acts as <code>p</code> peeked instead of committed on its
parse.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.between.html" title="combine::between fn">between</a></div><div class="item-right docblock-short"><p>Parses <code>open</code> followed by <code>parser</code> followed by <code>close</code>.
Returns the value of <code>parser</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.chainl1.html" title="combine::chainl1 fn">chainl1</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> 1 or more times separated by <code>op</code>. The value returned is the one produced by the
left associative application of the function returned by the parser <code>op</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.chainr1.html" title="combine::chainr1 fn">chainr1</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> one or more times separated by <code>op</code>. The value returned is the one produced by the
right associative application of the function returned by <code>op</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.choice.html" title="combine::choice fn">choice</a></div><div class="item-right docblock-short"><p>Takes a tuple, a slice or an array of parsers and tries to apply them each in order.
Fails if all the parsers fails or if an applied parser consumes input before failing.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.count.html" title="combine::count fn">count</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> from zero up to <code>count</code> times.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.count_min_max.html" title="combine::count_min_max fn">count_min_max</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> from <code>min</code> to <code>max</code> times (including <code>min</code> and <code>max</code>).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.eof.html" title="combine::eof fn">eof</a></div><div class="item-right docblock-short"><p>Succeeds only if the stream is at end of input, fails otherwise.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.from_str.html" title="combine::from_str fn">from_str</a></div><div class="item-right docblock-short"><p>Takes a parser that outputs a string like value (<code>&amp;str</code>, <code>String</code>, <code>&amp;[u8]</code> or <code>Vec&lt;u8&gt;</code>) and parses it
using <code>std::str::FromStr</code>. Errors if the output of <code>parser</code> is not UTF-8 or if
<code>FromStr::from_str</code> returns an error.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.look_ahead.html" title="combine::look_ahead fn">look_ahead</a></div><div class="item-right docblock-short"><p><code>look_ahead(p)</code> acts as <code>p</code> but doesn’t consume input on success.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.many.html" title="combine::many fn">many</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> zero or more times returning a collection with the values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.many1.html" title="combine::many1 fn">many1</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> one or more times returning a collection with the values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.none_of.html" title="combine::none_of fn">none_of</a></div><div class="item-right docblock-short"><p>Extract one token and succeeds if it is not part of <code>tokens</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.not_followed_by.html" title="combine::not_followed_by fn">not_followed_by</a></div><div class="item-right docblock-short"><p>Succeeds only if <code>parser</code> fails.
Never consumes any input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.one_of.html" title="combine::one_of fn">one_of</a></div><div class="item-right docblock-short"><p>Extract one token and succeeds if it is part of <code>tokens</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.optional.html" title="combine::optional fn">optional</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> and outputs <code>Some(value)</code> if it succeeds, <code>None</code> if it fails without
consuming any input. Fails if <code>parser</code> fails after having committed some input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parser.html" title="combine::parser fn">parser</a></div><div class="item-right docblock-short"><p>Wraps a function, turning it into a parser.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.position.html" title="combine::position fn">position</a></div><div class="item-right docblock-short"><p>Parser which just returns the current position in the stream.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.produce.html" title="combine::produce fn">produce</a></div><div class="item-right docblock-short"><p>Always returns the value produced by calling <code>f</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.satisfy.html" title="combine::satisfy fn">satisfy</a></div><div class="item-right docblock-short"><p>Parses a token and succeeds depending on the result of <code>predicate</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.satisfy_map.html" title="combine::satisfy_map fn">satisfy_map</a></div><div class="item-right docblock-short"><p>Parses a token and passes it to <code>predicate</code>. If <code>predicate</code> returns <code>Some</code> the parser succeeds
and returns the value inside the <code>Option</code>. If <code>predicate</code> returns <code>None</code> the parser fails
without consuming any input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sep_by.html" title="combine::sep_by fn">sep_by</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> zero or more time separated by <code>separator</code>, returning a collection with the
values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sep_by1.html" title="combine::sep_by1 fn">sep_by1</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> one or more time separated by <code>separator</code>, returning a collection with the
values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sep_end_by.html" title="combine::sep_end_by fn">sep_end_by</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> zero or more times separated and ended by <code>separator</code>, returning a collection
with the values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.sep_end_by1.html" title="combine::sep_end_by1 fn">sep_end_by1</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> one or more times separated and ended by <code>separator</code>, returning a collection
with the values from <code>p</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.skip_count.html" title="combine::skip_count fn">skip_count</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> from zero up to <code>count</code> times skipping the output of <code>parser</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.skip_count_min_max.html" title="combine::skip_count_min_max fn">skip_count_min_max</a></div><div class="item-right docblock-short"><p>Parses <code>parser</code> from <code>min</code> to <code>max</code> times (including <code>min</code> and <code>max</code>)
skipping the output of <code>parser</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.skip_many.html" title="combine::skip_many fn">skip_many</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> zero or more times ignoring the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.skip_many1.html" title="combine::skip_many1 fn">skip_many1</a></div><div class="item-right docblock-short"><p>Parses <code>p</code> one or more times ignoring the result.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.token.html" title="combine::token fn">token</a></div><div class="item-right docblock-short"><p>Parses a character and succeeds if the character is equal to <code>c</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.tokens.html" title="combine::tokens fn">tokens</a></div><div class="item-right docblock-short"><p>Parses multiple tokens.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.tokens_cmp.html" title="combine::tokens_cmp fn">tokens_cmp</a></div><div class="item-right docblock-short"><p>Parses multiple tokens.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.unexpected.html" title="combine::unexpected fn">unexpected</a></div><div class="item-right docblock-short"><p>Always fails with <code>message</code> as an unexpected error.
Never consumes any input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.unexpected_any.html" title="combine::unexpected_any fn">unexpected_any</a></div><div class="item-right docblock-short"><p>Always fails with <code>message</code> as an unexpected error.
Never consumes any input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.value.html" title="combine::value fn">value</a></div><div class="item-right docblock-short"><p>Always returns the value <code>v</code> without consuming any input.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.StdParseResult.html" title="combine::StdParseResult type">StdParseResult</a></div><div class="item-right docblock-short"><p>A type alias over the specific <code>Result</code> type used by parsers to indicate whether they were
successful or not.
<code>O</code> is the type that is output on success.
<code>Input</code> is the specific stream type used in the parser.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="combine" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0 (fe5b13d68 2022-05-18)" ></div>
</body></html>