window.SIDEBAR_ITEMS = {"enum":[["ErrorKind","Indicates which parser returned an error"],["Needed","Contains information on needed data if a parser returned `Incomplete`"]],"fn":[["align32","Align input value to the next multiple of 4 bytes"],["align_n2","Align input value to the next multiple of n bytes Valid only if n is a power of 2"],["be_var_u64","Read the entire slice as a big endian unsigned integer, up to 8 bytes"],["bytes_to_u64","Read an entire slice as a big-endian value."],["cond_else","Helper macro for nom parsers: run first parser if condition is true, else second parser"],["flat_take","Return a closure that takes `len` bytes from input, and applies `parser`."],["flat_takec","Take `len` bytes from `input`, and apply `parser`."],["le_var_u64","Read the entire slice as a little endian unsigned integer, up to 8 bytes"],["make_error","Creates an error from the input position and an [ErrorKind]"],["parse_hex_to_u64","Read a slice as a big-endian value."],["pure","Create a combinator that returns the provided value, and input unchanged"],["upgrade_error","Apply combinator, automatically converts between errors if the underlying type supports it"]],"trait":[["ParseError","This trait must be implemented by the error type of a nom parser."],["Parser","All nom parsers implement this trait"]],"type":[["IResult","Holds the result of parsing functions"]]};